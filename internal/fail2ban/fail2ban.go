package fail2ban

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"server-config/internal/config"
)

const (
	fail2banConfigDir = "/etc/fail2ban"
	jailLocalPath     = "/etc/fail2ban/jail.local"
	jailConfigPath    = "/etc/fail2ban/jail.conf"
	filterDir         = "/etc/fail2ban/filter.d"
	actionDir         = "/etc/fail2ban/action.d"
)

func InstallAndConfigure(cfg *config.Config) error {
	fmt.Println("Installing Fail2Ban...")
	if err := installFail2Ban(cfg); err != nil {
		return fmt.Errorf("failed to install Fail2Ban: %w", err)
	}

	fmt.Println("Creating Fail2Ban configuration...")
	if err := createFail2BanConfig(cfg); err != nil {
		return fmt.Errorf("failed to create Fail2Ban config: %w", err)
	}

	fmt.Println("Creating custom filters...")
	if err := createCustomFilters(cfg); err != nil {
		return fmt.Errorf("failed to create custom filters: %w", err)
	}

	fmt.Println("Starting Fail2Ban service...")
	if err := cfg.EnableService("fail2ban"); err != nil {
		return fmt.Errorf("failed to start Fail2Ban service: %w", err)
	}

	return nil
}

func installFail2Ban(cfg *config.Config) error {
	packages := []string{"fail2ban"}

	if !cfg.ServiceExists("fail2ban") {
		if err := cfg.InstallPackage(packages...); err != nil {
			return fmt.Errorf("failed to install Fail2Ban packages: %w", err)
		}
	}

	// Ensure configuration directory exists
	if err := os.MkdirAll(filterDir, 0755); err != nil {
		return fmt.Errorf("failed to create filter directory: %w", err)
	}
	if err := os.MkdirAll(actionDir, 0755); err != nil {
		return fmt.Errorf("failed to create action directory: %w", err)
	}

	return nil
}

func createFail2BanConfig(cfg *config.Config) error {
	// Create comprehensive jail.local configuration
	jailConfig := generateJailConfig(cfg)

	if err := cfg.WriteFile(jailLocalPath, jailConfig); err != nil {
		return fmt.Errorf("failed to write jail.local: %w", err)
	}

	// Set proper permissions
	if err := cfg.RunCommand("chmod", "644", jailLocalPath); err != nil {
		return fmt.Errorf("failed to set jail.local permissions: %w", err)
	}

	return nil
}

func generateJailConfig(cfg *config.Config) string {
	return fmt.Sprintf(`# Fail2Ban comprehensive configuration
# This file is generated by server-config

[DEFAULT]
# Ban IP for 1 hour (3600 seconds)
bantime = 3600
# Find IP for 10 minutes
findtime = 600
# Max 3 retry attempts
maxretry = 3
# Use iptables for firewall
banaction = iptables-multiport
# Send email notifications
action = %(action_mw)s
# Enable logging
loglevel = INFO

# Email configuration
destemail = root@localhost
sender = fail2ban@localhost
mta = sendmail

# Chain for fail2ban
chain = INPUT

[sshd]
enabled  = true
port     = %d
filter   = sshd
logpath  = /var/log/auth.log
maxretry = 3
bantime  = 3600
findtime = 600

[sshd-ddos]
enabled  = true
port     = %d
filter   = sshd-ddos
logpath  = /var/log/auth.log
maxretry = 2
bantime  = 7200
findtime = 300

[apache-auth]
enabled  = true
port     = http,https
filter   = apache-auth
logpath  = /var/log/apache2/error.log
maxretry = 6
bantime  = 1800
findtime = 600

[apache-badbots]
enabled  = true
port     = http,https
filter   = apache-badbots
logpath  = /var/log/apache2/access.log
bantime  = 86400
maxretry = 1

[apache-noscript]
enabled  = true
port     = http,https
filter   = apache-noscript
logpath  = /var/log/apache2/error.log
maxretry = 6
bantime  = 3600

[apache-overflows]
enabled  = true
port     = http,https
filter   = apache-overflows
logpath  = /var/log/apache2/error.log
maxretry = 2
bantime  = 3600

[nginx-http-auth]
enabled  = true
port     = http,https
filter   = nginx-http-auth
logpath  = /var/log/nginx/error.log
maxretry = 6
bantime  = 1800

[nginx-limit-req]
enabled  = true
port     = http,https
filter   = nginx-limit-req
logpath  = /var/log/nginx/error.log
maxretry = 10
bantime  = 600

[nginx-botsearch]
enabled  = true
port     = http,https
filter   = nginx-botsearch
logpath  = /var/log/nginx/error.log
maxretry = 2
bantime  = 86400

[postfix]
enabled  = true
port     = smtp,ssmtp,submission
filter   = postfix
logpath  = /var/log/mail.log
maxretry = 5
bantime  = 1800

[postfix-sasl]
enabled  = true
port     = smtp,ssmtp,submission
filter   = postfix-sasl
logpath  = /var/log/mail.log
maxretry = 3
bantime  = 3600

[dovecot]
enabled  = true
port     = pop3,pop3s,imap,imaps
filter   = dovecot
logpath  = /var/log/mail.log
maxretry = 5
bantime  = 1800

[mysqld-auth]
enabled  = true
port     = 3306
filter   = mysqld-auth
logpath  = /var/log/mysql/error.log
maxretry = 5
bantime  = 3600

[recidive]
enabled  = true
filter   = recidive
logpath  = /var/log/fail2ban.log
action   = iptables-allports[name=recidive]
bantime  = 604800
findtime = 86400
maxretry = 5

[apache-fakegooglebot]
enabled  = true
port     = http,https
filter   = apache-fakegooglebot
logpath  = /var/log/apache2/access.log
maxretry = 1
bantime  = 86400

[apache-modsecurity]
enabled  = true
port     = http,https
filter   = apache-modsecurity
logpath  = /var/log/apache2/error.log
maxretry = 2
bantime  = 3600

[apache-nohome]
enabled  = true
port     = http,https
filter   = apache-nohome
logpath  = /var/log/apache2/error.log
maxretry = 2
bantime  = 3600

[php-url-fopen]
enabled  = true
port     = http,https
filter   = php-url-fopen
logpath  = /var/log/apache2/access.log
maxretry = 1
bantime  = 3600

[webmin-auth]
enabled  = true
port     = 10000
filter   = webmin-auth
logpath  = /var/log/auth.log
maxretry = 3
bantime  = 3600

[wuftpd]
enabled  = true
port     = ftp,ftp-data,ftps,ftps-data
filter   = wuftpd
logpath  = /var/log/auth.log
maxretry = 6
bantime  = 1800

[vsftpd]
enabled  = true
port     = ftp,ftp-data,ftps,ftps-data
filter   = vsftpd
logpath  = /var/log/auth.log
maxretry = 6
bantime  = 1800

[pam-generic]
enabled  = true
filter   = pam-generic
logpath  = /var/log/auth.log
maxretry = 6
bantime  = 1800

[xinetd-fail]
enabled  = true
filter   = xinetd-fail
logpath  = /var/log/daemon.log
maxretry = 2
bantime  = 3600

[asterisk]
enabled  = true
port     = 5060
filter   = asterisk
logpath  = /var/log/asterisk/messages
maxretry = 10
bantime  = 600
`, cfg.SSHPort, cfg.SSHPort)
}

func createCustomFilters(cfg *config.Config) error {
	filters := map[string]string{
		"sshd-ddos.conf": `# Fail2Ban filter for SSH DoS attacks
[Definition]
# Monitor for SSH DoS attempts
failregex = ^.* sshd\[\d+\]: Did not receive identification string from <HOST>
            ^.* sshd\[\d+\]: Bad protocol version identification '.*' from <HOST>
            ^.* sshd\[\d+\]: Received disconnect from <HOST>: 11:  [preauth]
            ^.* sshd\[\d+\]: Read from socket failed: Connection reset by peer [preauth]
ignoreregex =
`,

		"apache-fakegooglebot.conf": `# Fail2Ban filter for fake Google bots
[Definition]
# Block fake Google bots
failregex = ^<HOST> -.*"(GET|POST).*".*"(?!Googlebot|Googlebot-Image|Googlebot-Video|Googlebot-News|Googlebot-Mobile|Googlebot-News|Googlebot-Image|Googlebot-Video).*
ignoreregex =
`,

		"nginx-limit-req.conf": `# Fail2Ban filter for Nginx rate limiting
[Definition]
# Monitor Nginx rate limiting
failregex = ^.* limiting requests, excess: .* by zone .*, client: <HOST>
ignoreregex =
`,

		"php-url-fopen.conf": `# Fail2Ban filter for PHP URL fopen exploits
[Definition]
# Block PHP URL fopen exploit attempts
failregex = ^.* PHP Warning:  fopen\((http|ftp)://.*\): failed to open stream: .* <HOST>
ignoreregex =
`,

		"web-shell.conf": `# Fail2Ban filter for web shell attacks
[Definition]
# Block web shell upload and execution attempts
failregex = ^.* \[client <HOST>\] .* ((eval|base64_decode|shell_exec|system|exec|passthru)\(|(\.php\?cmd=))
ignoreregex =
`,

		"brute-force.conf": `# Fail2Ban filter for general brute force attacks
[Definition]
# Block repeated failed authentication attempts
failregex = ^.* authentication failure;.* rhost=<HOST>
            ^.* Failed password for .* from <HOST> port .* ssh2
            ^.* Invalid user .* from <HOST> port
ignoreregex =
`,

		"port-scan.conf": `# Fail2Ban filter for port scanning
[Definition]
# Block port scanning attempts
failregex = ^.* (UFW|iptables).*(SRC=<HOST>).*(PROTO=TCP).*(DPT=\d+).*
ignoreregex =
`,

		"sqli.conf": `# Fail2Ban filter for SQL injection attempts
[Definition]
# Block SQL injection attempts
failregex = ^.* \[client <HOST>\] .* ((union|select|insert|update|delete|drop|create|alter|exec|execute)\s|('|%27|;|%3B))
ignoreregex =
`,

		"xss.conf": `# Fail2Ban filter for XSS attacks
[Definition]
# Block XSS attack attempts
failregex = ^.* \[client <HOST>\] .* ((<script|<iframe|<object|<embed)\s|javascript:|onload=|onerror=)
ignoreregex =
`,

		"wp-login.conf": `# Fail2Ban filter for WordPress login attacks
[Definition]
# Block WordPress brute force login attempts
failregex = ^.* \[client <HOST>\] .* POST .*/wp-login\.php.*
ignoreregex =
`,
	}

	// Write each filter file
	for filename, content := range filters {
		filterPath := filepath.Join(filterDir, filename)
		if err := cfg.WriteFile(filterPath, content); err != nil {
			return fmt.Errorf("failed to write filter %s: %w", filename, err)
		}
		if err := cfg.RunCommand("chmod", "644", filterPath); err != nil {
			return fmt.Errorf("failed to set permissions for filter %s: %w", filename, err)
		}
	}

	return nil
}

func createCustomActions(cfg *config.Config) error {
	actions := map[string]string{
		"iptables-multiport-log.conf": `# Fail2Ban action with enhanced logging
[INCLUDES]
before = iptables-common.conf

[Definition]
actionstart = iptables -N f2b-<name>
              iptables -A f2b-<name> -j RETURN
              iptables -I <chain> -p <protocol> -m multiport --dports <port> -j f2b-<name>

actionstop = iptables -D <chain> -p <protocol> -m multiport --dports <port> -j f2b-<name>
             iptables -F f2b-<name>
             iptables -X f2b-<name>

actioncheck = iptables -n -L <chain> | grep -q 'f2b-<name>[ \t]'

actionban = iptables -I f2b-<name> 1 -s <ip> -j <blocktype>
            echo "[<name>] Banned <ip> (failures: <failures>, time: <time>)" >> /var/log/fail2ban.log

actionunban = iptables -D f2b-<name> -s <ip> -j <blocktype>
              echo "[<name>] Unbanned <ip>" >> /var/log/fail2ban.log

[Init]
blocktype = REJECT --reject-with icmp-port-unreachable
`,

		"mail-whois.conf": `# Fail2Ban mail action with whois
[Definition]
actionstart =
actionstop =
actioncheck =
actionban = printf %%b "Subject: [Fail2Ban] <name>: banned <ip>\n
            From: Fail2Ban <<sender>>
            To: <dest>\n
            Hi,\n
            The IP <ip> has just been banned by Fail2Ban after <failures> attempts against <name>.\n\n
            Here is more information about <ip>:\n\n
            "` + "`whois <ip>`" + `"\n\n
            Regards,\n
            Fail2Ban" | /usr/sbin/sendmail -f <sender> <dest>

actionunban =
`,

		"iptables-ipset-proto6.conf": `# IPv6 aware iptables action with ipset
[INCLUDES]
before = iptables-ipset-common.conf

[Definition]
actionstart = ipset -exist create f2b-<name> hash:ip family inet6 timeout <bantime>
              ipset -exist create f2b-<name>4 hash:ip family inet timeout <bantime>
              iptables -I <chain> 1 -m set --match-set f2b-<name> src -j <blocktype>
              iptables -I <chain> 1 -m set --match-set f2b-<name>4 src -j <blocktype>

actionstop = iptables -D <chain> -m set --match-set f2b-<name> src -j <blocktype>
             iptables -D <chain> -m set --match-set f2b-<name>4 src -j <blocktype>
             ipset flush f2b-<name>
             ipset flush f2b-<name>4
             ipset destroy f2b-<name>
             ipset destroy f2b-<name>4

actioncheck = iptables -n -L <chain> | grep -q 'f2b-<name>[ \t]' && ipset -q list f2b-<name>

actionban = ipset -exist add f2b-<name> <ip> timeout <bantime>
            ipset -exist add f2b-<name>4 <ip> timeout <bantime>

actionunban = ipset -exist del f2b-<name> <ip>
              ipset -exist del f2b-<name>4 <ip>

[Init]
blocktype = REJECT --reject-with icmp-port-unreachable
`,
	}

	// Write each action file
	for filename, content := range actions {
		actionPath := filepath.Join(actionDir, filename)
		if err := cfg.WriteFile(actionPath, content); err != nil {
			return fmt.Errorf("failed to write action %s: %w", filename, err)
		}
		if err := cfg.RunCommand("chmod", "644", actionPath); err != nil {
			return fmt.Errorf("failed to set permissions for action %s: %w", filename, err)
		}
	}

	return nil
}

func ValidateConfiguration(cfg *config.Config) error {
	fmt.Println("Validating Fail2Ban configuration...")

	// Check if fail2ban is installed
	if !cfg.ServiceExists("fail2ban") {
		return fmt.Errorf("Fail2Ban service is not installed")
	}

	// Check if fail2ban is enabled
	if !cfg.ServiceEnabled("fail2ban") {
		return fmt.Errorf("Fail2Ban service is not enabled")
	}

	// Check if jail.local exists
	if !cfg.FileExists(jailLocalPath) {
		return fmt.Errorf("jail.local configuration file not found")
	}

	// Validate jail.local content
	jailContent, err := cfg.ReadFile(jailLocalPath)
	if err != nil {
		return fmt.Errorf("could not read jail.local: %w", err)
	}

	// Check essential configurations
	essentialConfigs := []string{
		"[DEFAULT]",
		"bantime = 3600",
		"findtime = 600",
		"maxretry = 3",
		fmt.Sprintf("port = %d", cfg.SSHPort),
		"[sshd]",
		"enabled = true",
	}

	for _, config := range essentialConfigs {
		if !strings.Contains(jailContent, config) {
			return fmt.Errorf("essential Fail2Ban configuration missing: %s", config)
		}
	}

	// Check if custom filters exist
	expectedFilters := []string{
		"sshd-ddos.conf",
		"apache-fakegooglebot.conf",
		"nginx-limit-req.conf",
		"php-url-fopen.conf",
		"web-shell.conf",
	}

	for _, filter := range expectedFilters {
		filterPath := filepath.Join(filterDir, filter)
		if !cfg.FileExists(filterPath) {
			return fmt.Errorf("custom filter not found: %s", filter)
		}
	}

	// Test fail2ban configuration
	if err := cfg.RunCommand("fail2ban-client", "test"); err != nil {
		return fmt.Errorf("Fail2Ban configuration test failed: %w", err)
	}

	fmt.Println("✓ Fail2Ban is installed and running")
	fmt.Println("✓ Jail configuration is valid")
	fmt.Printf("✓ SSH jail configured on port %d\n", cfg.SSHPort)
	fmt.Println("✓ Custom security filters are installed")
	fmt.Println("✓ Fail2Ban configuration test passed")

	return nil
}
